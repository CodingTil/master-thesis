\section{Mastervariable Synchronization}\label{sec:implementation_sync}
As elaborated in Section \ref{sec:gm_sync}, there is a need to synchronize the information of new columns being generated across the entire search tree. While this need arose in the context of branching using generic mastercuts, we would explicitly like to emphasize that this synchronization is a general requirement for any branching rule that does not formulate its branching decisions in the original problem. For this reason, we have decoupled the synchronization of mastervariables from the generic mastercut interface, and instead implemented it as a separate internal module within \GCG{}.

\begin{lstlisting}[language=C, caption=Variable History Construct]
struct GCG_VARHISTORYBUFFER {
	SCIP_VAR*             vars[50];
	int                   nvars;
	GCG_VARHISTORYBUFFER* next;
	int                   nuses;
};

struct GCG_VARHISTORY {
	GCG_VARHISTORYBUFFER* buffer;
	int                   pos;
};
\end{lstlisting}

To enable such mastervariable synchronization, we have implemented the history tracking approach using unrolled linked lists as described in Section \ref{subsec:gm_sync_history_unrolled}. It is set up such that each element, or \textit{buffer}, in the unrolled linked list has a default capacity of 50 variables. The variable \texttt{nuses}, the \textit{reference count}, keeps track of how many strong pointers of type \texttt{GCG\_VARHISTORY} are currently pointing to the buffer. The \texttt{GCG\_VARHISTORY} structure itself is a simple wrapper around the buffer, keeping track of the current position in the buffer. As a result, each strong pointer still points to a specific variable. The \GCG{} pricer is responsible for managing the global variable history list, appending new variables whenever a new column is generated. In Section \ref{sec:gm_sync} we have denoted this central reference as the \texttt{Latest} pointer.

We can now synchronize mastervariables by attaching a strong reference to each node in the search tree. More specifically, upon node creation, we create reference identical to the \texttt{Latest} pointer stored in the \GCG{} pricer. Then, following the procedure described in Section \ref{subsec:gm_sync_history}, we forward these strong pointers upon node (de-)activation. To inform a branching rule in a specific node of the creation of a new variable, we have further extended the \GCG{} branching rule interface by the following callback function. The branching rule may then, for example, determine the constraint coefficient for this new mastervariable.

\begin{lstlisting}[language=C, caption=Branching Rule Interface Extension]
#define GCG_DECL_BRANCHNEWCOL(x) SCIP_RETCODE x (SCIP* scip, GCG_BRANCHDATA* branchdata, SCIP_VAR* mastervar)
\end{lstlisting}

Finally, we note that each \texttt{SCIP\_VAR} already contains a flag whether it has been deleted from the problem. We use this flag instead of marking such variables as deleted in the history buffer ourselves.
