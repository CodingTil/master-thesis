\section{Comparison to Vanderbeck's Generic Branching}\label{sec:cmpbnd_simdif}
Both the generic branching scheme by Vanderbeck (Section \ref{sec:cg_bp_bp_branching_generic}) and the proposed component bound scheme involve branching in the master problem by imposing bounds on the original variables within the \SP{}. The primary difference lies in how these component bounds are imposed. \texttt{GENERIC} branching enforces these bounds as hard constraints, effectively subdividing the solution space of the original variables. Consequently, when the optimal solution $\vec{x}^*$ to the \IP{} is found in a branch-and-bound node of the \RMP{}, it satisfies all the component bounds imposed by the branching decisions from the root to that node. In contrast, our approach adds these bounds as soft constraints, allowing both columns that satisfy and those that violate the component bounds to be generated.

While the component bound branching rule might be easier to implement, branching using Vanderbeck's generic scheme has a significant advantage: It only requires tightening the bounds of the original variables in the \SP{}, whereas \texttt{COMPBND} branching introduces new variables and constraints. This is a significant advantage, since the structure of the pricing problem does not change. Many dynamic programming solvers for specific \IP{}s can handle changing variable bounds, and can therefore continue to generate columns efficiently, even after branching. This is unfortunately not the case for our approach, where the pricing problem changes with each branching decision, possibly forcing us to fall back to a generic \MIP{} solver. Furthermore, the \texttt{GENERIC} scheme tightens the bounds further as we descend deeper into the search tree, which in turn means that the pricing problem becomes increasingly easier to solve. In contrast, \texttt{COMPBND} branching will add more and more variables and constraints, which will further complicate the \SP{}.
