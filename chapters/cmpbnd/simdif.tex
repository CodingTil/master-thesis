\section{Comparison to Vanderbeck's Generic Branching}\label{sec:cmpbnd_simdif}
Both the generic branching scheme by Vanderbeck (Section \ref{sec:cg_bp_bp_branching_generic}) and the proposed component bound scheme branch in the master by imposing bounds on the original variables within the \SP{}. The main difference is, that Vanderbeck enforces these bounds as hard constraints, while we only add soft constraints. One could say, that by applying Vanderbeck branching, one literally partitions the solution space of the original variables. As a result, when we find the optimal solution $\vec{x}^*$ to the \IP{} in some node in the branch-and-bound tree of the \RMP{}, we know that $\vec{x}^*$ satisfies all the component bounds imposed by the branching decisions along the path from the root to this node. In contrast, in our approach both columns satisfying and violating the component bounds can be generated.

While the component bound branching rule might be easier to implement, branching using Vanderbeck's generic scheme has a significant advantage: It only requires tightening the bounds of the original variables in the \SP{}, whereas our approach introduces new variables and constraints. This is a significant advantage, since the structure of the pricing problem does not change. Many dynamic programming solvers for specific \IP{}s can handle changing variable bounds, and can therefore continue to generate columns efficiently, even after branching. This is unfortunately not the case for our approach, where the pricing problem changes with each branching decision, forcing us to fall back to a generic \IP{} solver.
