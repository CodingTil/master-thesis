\chapter{Master Constraints without corresponding Original Problem Constraints}\label{ch:gm}
In addition to implementing the component bound branching rule (Chapter \ref{ch:cmpbnd}), a significant goal of this thesis is to enable future \GCG{} developers to easily create new branching rules and separators within the framework (Section \ref{sec:tools_gcg}). Currently, \GCG{} has limitations: branching rules must either produce decisions formulated in the original problem, which can then be Dantzig-Wolfe reformulated and added to the master and pricing problems (as seen when branching on original variables in Section \ref{sec:cg_bp_bp_branching_original}), or they must produce constraints for the master problem without requiring modifications to the pricing problem, as seen with Ryan-Foster branching. Other branching rules, such as Vanderbeck's generic branching scheme (Section \ref{sec:cg_bp_bp_branching_generic}), cannot be implemented without significant changes to the \GCG{} framework. These changes would involve applying and removing component bounds in the pricing problem when a B\&B-node is entered or left. Our proposed component bound branching rule (Chapter \ref{ch:cmpbnd}) and any separators using the master problem (Section \ref{sec:cg_bp_bpc_separators_master}) would also require such changes. The reason is that \GCG{} does not currently support imposing constraints in the master problem that necessitate modifications to at least one \SP{}, where the master constraints and induced pricing problem modifications are not a product of a Dantzig-Wolfe reformulation of the original problem and do not necessarily have a counterpart in the original problem.

In this chapter, we will specify the notation of such constraints, referred to as \textbf{generic mastercuts}. We will present our integration of these constraints into the \GCG{} framework as part of a new interface and demonstrate how to apply dual value stabilization to these constraints.

First, let us define the concept of a generic mastercut, which unites Vanderbeck's generic branching scheme, our component bound branching rule, and any master separators.

\begin{definition}
A \textbf{generic mastercut} is a constraint in the master problem that does not have a counterpart in the original problem, and therefore requires modification to one or multiple \SP{} to ensure its validity in the master. Specifically, it takes the following form:
\begin{equation*}
\sum_{p \in P} f_p \lambda_p + \sum_{r \in R} f_r \lambda_r \leq f' \quad \left[\gamma\right]
\end{equation*}

The subproblems are now responsible for correctly determining the coefficients $f_p$ and $f_r$ of all newly generated columns $p$ and $r$.
\end{definition}

\begin{definition}
A \textbf{pricing modification} to the subproblem $\SP{k}$ in block $k$, associated with a generic mastercut with dual value $\gamma$, is a set of constraints and variables added to the subproblem to ensure the validity of the generic mastercut in the master problem with respect to new variables.

Every pricing modification includes at least one mandatory variable $y$ with an objective coefficient of $-\gamma$ in the $\SP{k}$. The solution value of $y$ is used as the column entry for the master constraint of the generic mastercut, i.e., $f_p$ or $f_r$. This variable is known as the \textbf{coefficient variable} of the pricing modification. All additional variables will take on auxiliary roles in the pricing problem and have an objective coefficient of zero.
\end{definition}

// TODO: which places do we add them?
// TODO: how can we use them in branching rules?

\input{chapters/gm/sync}
\input{chapters/gm/dvs}