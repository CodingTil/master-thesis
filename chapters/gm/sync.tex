\section{Mastervariable Synchronization across the entire B\&B-Tree}\label{sec:gm_sync}
\begin{figure}[H]
\centering
\tikzset{every tree node/.style={minimum width=2em,draw,circle},
			blank/.style={draw=none},
			edge from parent/.style=
			{draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
			level distance=1.5cm, sibling distance=2.5em}
\begin{tikzpicture}
\Tree
[.A
	[.B
		[.D ]
		[.E ]
	]
	[.C
		[.F ]
		[.G ]
	]
]
\end{tikzpicture}
\caption{An exemplary B\&B-tree created by the component bound branching rule, where the lexicographic order of the nodes resembles the order in which they were created.}
\label{fig:gm_sync_tree}
\end{figure}

Generic mastercuts used as branching decisions need to be aware of all columns currently existing in the \RMP{}. For instance, in component bound branching (Chapter \ref{ch:cmpbnd}), all columns satisfying the branching decision must have a coefficient of $1$ for the mastercut. This can be easily managed when creating the branching decision and when a new column is generated in the subtree of the node where the decision was made. However, consider the following scenario in a branch-and-bound tree generated with the component bound branching rule, as depicted in Figure \ref{fig:gm_sync_tree}: we are currently processing node F in the B\&B-tree and generate a new column $q'$. After deactivating node F and activating node D, it is possible that $x_{q'}$ satisfies the component bounds imposed in D. Thus, $q'$ should have a coefficient of $1$ in the mastercut of D. However, since the column was generated in F, it is not known to D, potentially invalidating the mastercut of D.

To prevent this, branching decisions must be aware of these columns to update their coefficients accordingly. Specifically, we want to synchronize newly generated master variables across the entire B\&B-tree lazily, i.e., only when a node is activated. Moreover, in \GCG{}, master variables deemed unnecessary can be removed from the master problem, and deleted variables should not require synchronization.

In this section, we will first analyze the current approach taken by the implementation of Vanderbeck's generic branching in \GCG{}. Then, we will present a more efficient approach, referred to as \textbf{history tracking}, and further optimize it.

\subsection{Current Approach used by the Implementation of Vanderbeck's Generic Branching}\label{subsec:gm_sync_current}
In the current implementation of Vanderbeck's generic branching in \GCG{}, each node created by this branching rule stores the number of master variables it is aware of. This number is updated whenever a node is deactivated to reflect any newly generated columns. Upon node activation, the current number of variables in the master is compared against how many variables were present the last time the node was active. If new columns have been added to the \RMP{} in the meantime, this counter might increase. If so, the coefficient for the new columns will be determined and set in the \RMP{}.

Unfortunately, this approach is not complete, as not all new columns are necessarily detected. For instance, if one column was generated and another column was deleted in the meantime, the counter would not increase, as the number of columns in the master would remain the same. Consequently, the coefficient for the new column would not be set in the mastercut, potentially leading to invalid mastercuts.

Additionally, this approach is not developer-friendly. Developers of branching rules should not have to manage when and where columns are generated and deleted. This should be handled by the framework, requiring developers to only implement an interface method responsible for setting the coefficient of any column, regardless of where it was generated.

\subsection{History Tracking Approach}\label{subsec:gm_sync_history}
\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node0) [historynode] at (0,0) {\nodepart{one} $q_0$ \nodepart{two} $1$};
\node (node1) [historynode,right=of node0] {\nodepart{one} $q_1$ \nodepart{two} $1$};
\node (node2) [historynode,right=of node1] {\nodepart{one} $q_2$ \nodepart{two} $3$};
\node (node3) [historynode,right=of node2] {\nodepart{one} $q_3$ \nodepart{two} $2$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $2$};

% Edges
\draw[->] (node0.two east) -- (node1.one west);
\draw[->] (node1.two east) -- (node2.one west);
\draw[->] (node2.two east) -- (node3.one west);
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);

% External references
\draw[->,dashed] (node0.one split south) ++(0,-1) node[below,draw=none] {C} -- ++(0,1);
\draw[->,dashed] (node2.one split south) ++(-0.3,-1) node[below,draw=none] {A} -- ++(0.2,1);
\draw[->,dashed] (node2.one split south) ++(0.3,-1) node[below,draw=none] {B} -- ++(-0.2,1);
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(0,-1) node[below,draw=none] {\texttt{Latest}} -- ++(0,1);

\end{tikzpicture}
\caption{Reference-counted linked list of the history of columns added to the \RMP{}, with external references drawn dashed from below, e.g., those from the B\&B-tree nodes A, B, and C. Each element holds a reference to the master variable belonging to column $q_i$, as well as the number of references to itself.}
\label{fig:gm_sync_history}
\end{figure}

We propose a highly efficient approach to lazily notify all nodes in the B\&B-tree of new columns generated while also considering deleted columns. We introduce a reference-counted linked list of variables added to the \RMP{}, where the order of the variables in the list is determined by their generation order. Each node in the B\&B-tree holds its own external reference to this construct. The specific element in the list that a B\&B-tree node points to signifies the last column in the \RMP{} when the node was last active. All subsequent variables, i.e., the elements next in the list, are new columns generated elsewhere in the list. Additionally, we hold one external reference to the tail of the list, representing the last generated column. This construct is illustrated in Figure \ref{fig:gm_sync_history}. Since the linked list tracks which variables were created when we will refer to this list as the \texttt{varhistory}.

Let us consider a B\&B-tree with root node A and child nodes B and C. Currently, we are solving node B, and therefore nodes A and B are active. While solving B, we have generated columns $q_3$, $q_4$, and $q_5$. Assume we have solved the relaxation of B to optimality, finding a fractional solution, and have created two child nodes D and E. Both nodes will be created using all columns currently in the \RMP{}, i.e., $q_i, i \in \{0, 5\}$. For this reason, we use the \texttt{Latest} pointer to initialize the reference to the \texttt{varhistory} of D and E (Figure \ref{fig:gm_sync_history_d_e}).

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node0) [historynode] at (0,0) {\nodepart{one} $q_0$ \nodepart{two} $1$};
\node (node1) [historynode,right=of node0] {\nodepart{one} $q_1$ \nodepart{two} $1$};
\node (node2) [historynode,right=of node1] {\nodepart{one} $q_2$ \nodepart{two} $3$};
\node (node3) [historynode,right=of node2] {\nodepart{one} $q_3$ \nodepart{two} $2$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $4$};

% Edges
\draw[->] (node0.two east) -- (node1.one west);
\draw[->] (node1.two east) -- (node2.one west);
\draw[->] (node2.two east) -- (node3.one west);
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);

% External references
\draw[->,dashed] (node0.one split south) ++(0,-1) node[below,draw=none] {C} -- ++(0,1);
\draw[->,dashed] (node2.one split south) ++(-0.3,-1) node[below,draw=none] {A} -- ++(0.2,1);
\draw[->,dashed] (node2.one split south) ++(0.3,-1) node[below,draw=none] {B} -- ++(-0.2,1);
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(-1,-1) node[below,draw=none] {D} -- ++(0.7,1);
\draw[->,dashed] (node5.one split south) ++(-0.4,-1) node[below,draw=none] {E} -- ++(0.35,1);
\draw[->,dashed] (node5.one split south) ++(0.6,-1) node[below,draw=none] {\texttt{Latest}} -- ++(-0.5,1);

\end{tikzpicture}
\caption{\texttt{varhistory} after creating child nodes D and E of node B.}
\label{fig:gm_sync_history_d_e}
\end{figure}

Continuing this scenario, let \GCG{} deem the column $q_2$ unnecessary and remove it from the \RMP{}. Since there may be external references to this variable, which in this case there are, we do not remove the element in the list holding $q_2$. Instead, we mark it as deleted. Next, we would like to solve node C. For this, we must deactivate node B, and activate node A. Whenever we deactivate a node, we know that it and all its ancestors are already aware of all columns in the \RMP{}. Therefore, we may jump all the active node's pointers to the \texttt{Latest} pointer. This is illustrated in Figure \ref{fig:gm_sync_history_deactivate_B}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node0) [historynode] at (0,0) {\nodepart{one} $q_0$ \nodepart{two} $1$};
\node (node1) [historynode,right=of node0] {\nodepart{one} $q_1$ \nodepart{two} $1$};
\node (node2) [historynode,right=of node1] {\nodepart{one} $\stkout{q_2}$ \nodepart{two} $1$};
\node (node3) [historynode,right=of node2] {\nodepart{one} $q_3$ \nodepart{two} $2$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $6$};

% Edges
\draw[->] (node0.two east) -- (node1.one west);
\draw[->] (node1.two east) -- (node2.one west);
\draw[->] (node2.two east) -- (node3.one west);
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);

% External references
\draw[->,dashed] (node0.one split south) ++(0,-1) node[below,draw=none] {C} -- ++(0,1);
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(-1.3,-1) node[below,draw=none] {A} -- ++(1.1,1);
\draw[->,dashed] (node5.one split south) ++(-0.7,-1) node[below,draw=none] {B} -- ++(0.6,1);
\draw[->,dashed] (node5.one split south) ++(-0.1,-1) node[below,draw=none] {D} -- ++(0.05,1);
\draw[->,dashed] (node5.one split south) ++(0.5,-1) node[below,draw=none] {E} -- ++(-0.4,1);
\draw[->,dashed] (node5.one split south) ++(1.5,-1) node[below,draw=none] {\texttt{Latest}} -- ++(-1.2,1);

\end{tikzpicture}
\caption{\texttt{varhistory} after deletion of column $q_2$ and deactivation of node B.}
\label{fig:gm_sync_history_deactivate_B}
\end{figure}

Finally, we activate node C. Upon node activation, we realize that the element that C points to in the \texttt{varhistory} has a next element. This means that there are new columns that have been generated since the last time C was active. We forward the pointer of C one by one until reaching the \texttt{Latest} pointer. Each time we forward the pointer, if the variable $q_i$ is not marked as deleted, we pass it to the branching rule to set the coefficient of $q_i$ in the mastercut of C.

Whenever we forward a pointer, either step-by-step or by jumping to the \texttt{Latest} pointer, the internal reference count of the elements in the list is updated. As soon as this reference count reaches zero, the element can be safely freed. This ensures that only necessary variables, those that still need to be synchronized across the entire B\&B-tree, are kept in memory. This is illustrated in Figure \ref{fig:gm_sync_history_activate_C}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node3) [historynode] {\nodepart{one} $q_3$ \nodepart{two} $1$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $7$};

% Edges
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);

% External references
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(-1.6,-1) node[below,draw=none] {A} -- ++(1.3,1);
\draw[->,dashed] (node5.one split south) ++(-1,-1) node[below,draw=none] {B} -- ++(0.8,1);
\draw[->,dashed] (node5.one split south) ++(-0.4,-1) node[below,draw=none] {C} -- ++(0.3,1);
\draw[->,dashed] (node5.one split south) ++(0.2,-1) node[below,draw=none] {D} -- ++(-0.1,1);
\draw[->,dashed] (node5.one split south) ++(0.8,-1) node[below,draw=none] {E} -- ++(-0.6,1);
\draw[->,dashed] (node5.one split south) ++(1.8,-1) node[below,draw=none] {\texttt{Latest}} -- ++(-1.5,1);

\end{tikzpicture}
\caption{\texttt{varhistory} after activation of node C.}
\label{fig:gm_sync_history_activate_C}
\end{figure}

Assume node C we generates a new column $q_6$. We add this column to the \texttt{varhistory} by allocating a new list element, setting its reference count to $1$, setting the next pointer of the current \texttt{Latest} element to the new element, and finally forwarding the \texttt{Latest} pointer to the new element. This is illustrated in Figure \ref{fig:gm_sync_history_generate_q6}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node3) [historynode] {\nodepart{one} $q_3$ \nodepart{two} $1$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $6$};
\node (node6) [historynode,right=of node5] {\nodepart{one} $q_6$ \nodepart{two} $1$};

% Edges
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);
\draw[->] (node5.two east) -- (node6.one west);

% External references
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(-1.6,-1) node[below,draw=none] {A} -- ++(1.3,1);
\draw[->,dashed] (node5.one split south) ++(-1,-1) node[below,draw=none] {B} -- ++(0.8,1);
\draw[->,dashed] (node5.one split south) ++(-0.4,-1) node[below,draw=none] {C} -- ++(0.3,1);
\draw[->,dashed] (node5.one split south) ++(0.2,-1) node[below,draw=none] {D} -- ++(-0.1,1);
\draw[->,dashed] (node5.one split south) ++(0.8,-1) node[below,draw=none] {E} -- ++(-0.6,1);
\draw[->,dashed] (node6.one split south) ++(0,-1) node[below,draw=none] {\texttt{Latest}} -- ++(0,1);

\end{tikzpicture}
\caption{\texttt{varhistory} after generating column $q_6$ in node C.}
\label{fig:gm_sync_history_generate_q6}
\end{figure}

This approach is highly efficient as it updates the reference count of elements in the list and passes only new variables to the branching rule. The deletion of variables is not an issue, as we simply do not pass them to the branching rules. Once all external references have seen some variable $q_i$, i.e., its reference count reaches zero, we can automatically free the memory of the element in the list holding $q_i$. This minimizes the memory footprint of the \texttt{varhistory} construct.

And as a final note, this approach is not limited for synchronization of master variables across the B\&B-tree, but can also be used for other purposes, which have symbolized by the \textit{other} reference in the above figures. Such other purposes, for example would be keeping master separators up-to-date (Section \ref{sec:cg_bp_bpc_separators_master}). For more details on this, we refer to the thesis of Chantal Reinartz Groba \cite{reinartzgroba2024todo}.

\subsection{History Tracking using Unrolled Linked Lists Approach}\label{subsec:gm_sync_history_unrolled}
The previous approach has an optimization opportunity: the elements of the \texttt{varhistory} might be allocated in completely different memory locations, leading to poor cache utilization during traversal. Storing the entire list in a contiguous memory block could improve cache locality but could be costly if reallocation and copying are needed when space runs out.

We can optimize by unrolling the linked list into blocks storing a fixed number of columns, with each block having its own reference count. These blocks are linked together, forming a list of blocks. The references to the \texttt{varhistory} point to the blocks and hold an offset within the block. This way, each reference still refers to some $q_i$, enabling pointer forwarding one column at a time. A new variable is added to the tail block if space allows; otherwise, a new block is allocated. This concept is illustrated in Figure \ref{fig:gm_sync_history_unrolled}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=5,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node0) [historynode] at (0,0) {
	\nodepart{one} $q_0$
	\nodepart{two} $q_3$
	\nodepart{three} $q_2$
	\nodepart{four} $q_3$
	\nodepart{five} $3$
};
\node (node1) [historynode,right=of node0] {
	\nodepart{one} $q_4$
	\nodepart{two} $q_5$
	\nodepart{three}
	\nodepart{four}
	\nodepart{five} $3$
};

% Edges
\draw[->] (node0.two east) -- (node1.one west);

% External references
\draw[->,dashed] (node0.three south) ++(-1.8,-1) node[below,draw=none] {C,0} -- ++(1.6,1);
\draw[->,dashed] (node0.three south) ++(-0.9,-1) node[below,draw=none] {A,2} -- ++(0.8,1);
\draw[->,dashed] (node0.three south) ++(0,-1) node[below,draw=none] {B,2} -- ++(0,1);
\draw[->,dashed] (node0.three south) ++(1.2,-1) node[below,draw=none] {\textit{other},3} -- ++(-1.1,1);
\draw[->,dashed] (node1.three south) ++(0,-1) node[below,draw=none] {\texttt{Latest},1} -- ++(0,1);

\end{tikzpicture}
\caption{\texttt{varhistory} of Figure \ref{fig:gm_sync_history} unrolled into blocks of size 4.}
\label{fig:gm_sync_history_unrolled}
\end{figure}

This approach improves cache locality and reduces the total number of memory allocation and deallocation operations. From an outside perspective, the fundamental operations of the \texttt{varhistory} construct remain the same.
