\section{Mastervariable Synchronization across the entire B\&B-Tree}\label{sec:gm_sync}
\begin{figure}[H]
\centering
\tikzset{every tree node/.style={minimum width=2em,draw,circle},
			blank/.style={draw=none},
			edge from parent/.style=
			{draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
			level distance=1.5cm, sibling distance=2.5em}
\begin{tikzpicture}
\Tree
[.A
	[.B
		[.D ]
		[.E ]
	]
	[.C
		[.F ]
		[.G ]
	]
]
\end{tikzpicture}
\caption{An exemplary B\&B-tree, created by the component bound branching rule, where the lexicographic order of the nodes resembles the order in which they were created.}
\label{fig:gm_sync_tree}
\end{figure}

Generic mastercuts that are used as branching decisions need to be aware of all columns that currently exist in the \RMP{}, e.g. in the case of component bound branching (Chapter \ref{ch:cmpbnd}), all columns that satisfy the branching decision must have a coefficient of $1$ for the mastercut. This can be easily achieved when creating the branching decision, i.e. when creating the mastercut, and could be done automatically when a new column is generated in the subtree of the node where the branching decision was made. However, consider the following case in a branch-and-bound tree generated with the component bound branching rule (Figure \ref{fig:gm_sync_tree}): we currently process node F in the B\&B-tree and within that node generate a new column $q'$. Afterwards, we deactivate node F and activate node D. Now it could be that $x_{q'}$ satisfies the component bounds imposed in D, i.e. $q'$ should have a coefficient of $1$ in the mastercut of D. However, since the column was generated in F, it is not known to D, which might invalidate the mastercut of D.

To prevent this, we must make the branching decisions aware of these columns such that they can update their coefficients accordingly. In particular, we would like to synchronize newly generated master variables across the entire B\&B-tree lazily, i.e. only when a node is being activated. Furthermore, in \GCG{} master variables that are deemed unnecessary can be removed from the master problem. Deleted variables should not have to be synchronized.

In this section, we will first analyze the current approach taken by the implementation of Vanderbeck's generic branching in \GCG{}. Afterwards, we will present a more efficient approach accomplishing this task, which we will refer to as \textbf{history tracking}, and further optimize it.

\subsection{Current Approach used by the Implementation of Vanderbeck's Generic Branching}\label{subsec:gm_sync_current}
In the current implementation of Vanderbeck's generic branching in \GCG{}, each node created by this branching rule stores the number of master variables it is aware of. This number is updated whenever a node is being deactivated to reflect any newly generated columns. Upon node activation, the current number of variables in the master is compared against how many variables were present the last time the node was active. If in the meantime new columns have been added to the \RMP{}, this counter \textit{might} increase. If so, the coefficient for the new columns will be determined and set in the \RMP{}.

Unfortunately, this approach is not complete, as not all new columns are necessarily detected. For instance, consider the case where one column was generated, and another column was deleted in the meantime. The counter would not increase, as the number of columns in the master would remain the same. And for this reason, the coefficient for the new column would not be set in the mastercut. This could lead to invalid mastercuts, as described in the beginning of this section.

Furthermore, this approach is not very developer friendly. In our opinion, the developer of a branching rule should not have to deal with knowing when and where which columns are being generated and deleted. This should be handled by the framework, and the developer should only have to provide an implementation for an interface method responsible for setting the coefficient of any column, regardless of whether it was generated in the current node or not.

\subsection{History Tracking Approach}\label{subsec:gm_sync_history}
\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node0) [historynode] at (0,0) {\nodepart{one} $q_0$ \nodepart{two} $1$};
\node (node1) [historynode,right=of node0] {\nodepart{one} $q_1$ \nodepart{two} $1$};
\node (node2) [historynode,right=of node1] {\nodepart{one} $q_2$ \nodepart{two} $3$};
\node (node3) [historynode,right=of node2] {\nodepart{one} $q_3$ \nodepart{two} $2$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $2$};

% Edges
\draw[->] (node0.two east) -- (node1.one west);
\draw[->] (node1.two east) -- (node2.one west);
\draw[->] (node2.two east) -- (node3.one west);
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);

% External references
\draw[->,dashed] (node0.one split south) ++(0,-1) node[below,draw=none] {C} -- ++(0,1);
\draw[->,dashed] (node2.one split south) ++(-0.3,-1) node[below,draw=none] {A} -- ++(0.2,1);
\draw[->,dashed] (node2.one split south) ++(0.3,-1) node[below,draw=none] {B} -- ++(-0.2,1);
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(0,-1) node[below,draw=none] {\texttt{Latest}} -- ++(0,1);

\end{tikzpicture}
\caption{Reference-counted linked list of the history of columns added to the \RMP{}, with external references drawn dashed from below, e.g. those from the B\&B-tree nodes A, B, and C. Each element holds a reference to the master variable belonging to column $q_i$, as well as the number of references to itself.}
\label{fig:gm_sync_history}
\end{figure}

We propose a highly efficient approach to lazily notify all nodes in the B\&B-tree of new columns that have been generated, while also considering deleted columns. We introduce a reference-counted linked list of variables added to the \RMP{}, where the order of the variables in the list is determined by the order in which they were generated. Each node in the B\&B-tree holds its own external reference to this construct. In particular, the specific element in the list that such a B\&B-tree points to signifies the last column that was in the \RMP{} when the node was last active. All further variables, i.e. the elements next in the list, are new columns that have been generated elsewhere in the list. Additionally, we hold one external reference to the tail of the list, which is the last column that was generated. This construct is illustrated in Figure \ref{fig:gm_sync_history}. Since the linked list tracks which variables where created when, we will henceforth refer to this list as the \texttt{varhistory}. We will now describe how this construct is used to synchronize the master variables across the entire B\&B-tree.

Let us consider a B\&B-tree with root node A and child nodes B and C. Currently, we are solving node B, and therefore nodes A and B are active. While solving B, we have generated columns $q_3$, $q_4$, and $q_5$. Assume we have solved the relaxation of B to optimality, finding a fractional solution, and have therefore created two child nodes D and E. Both nodes will be created using all columns that are currently in the \RMP{}, i.e. $q_i, i \in \{0, 5\}$. For this reason, we use the \texttt{Latest} pointer initialize the reference to the \texttt{varhistory} of D and E (Figure \ref{fig:gm_sync_history_d_e}).

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node0) [historynode] at (0,0) {\nodepart{one} $q_0$ \nodepart{two} $1$};
\node (node1) [historynode,right=of node0] {\nodepart{one} $q_1$ \nodepart{two} $1$};
\node (node2) [historynode,right=of node1] {\nodepart{one} $q_2$ \nodepart{two} $3$};
\node (node3) [historynode,right=of node2] {\nodepart{one} $q_3$ \nodepart{two} $2$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $4$};

% Edges
\draw[->] (node0.two east) -- (node1.one west);
\draw[->] (node1.two east) -- (node2.one west);
\draw[->] (node2.two east) -- (node3.one west);
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);

% External references
\draw[->,dashed] (node0.one split south) ++(0,-1) node[below,draw=none] {C} -- ++(0,1);
\draw[->,dashed] (node2.one split south) ++(-0.3,-1) node[below,draw=none] {A} -- ++(0.2,1);
\draw[->,dashed] (node2.one split south) ++(0.3,-1) node[below,draw=none] {B} -- ++(-0.2,1);
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(-1,-1) node[below,draw=none] {D} -- ++(0.7,1);
\draw[->,dashed] (node5.one split south) ++(-0.4,-1) node[below,draw=none] {E} -- ++(0.35,1);
\draw[->,dashed] (node5.one split south) ++(0.6,-1) node[below,draw=none] {\texttt{Latest}} -- ++(-0.5,1);

\end{tikzpicture}
\caption{\texttt{varhistory} after creating child nodes D and E of node B.}
\label{fig:gm_sync_history_d_e}
\end{figure}

Continuing this scenario, let \GCG{} now deem the column $q_2$ to be unnecessary and remove it from the \RMP{}. Since there may be external references to this variable, which in this case there are, we do not remove the element in the list holding $q_2$. Instead, we simply mark it as deleted. Next, we would like to solve node C. For this, we must deactivate node B, and activate node A. Whenever we deactivate a node, we know that it and all its ancestors are already aware of all columns in the \RMP{}. Therefore, we may jump all the active node's pointers to the \texttt{Latest} pointer. This is illustrated in Figure \ref{fig:gm_sync_history_deactivate_B}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node0) [historynode] at (0,0) {\nodepart{one} $q_0$ \nodepart{two} $1$};
\node (node1) [historynode,right=of node0] {\nodepart{one} $q_1$ \nodepart{two} $1$};
\node (node2) [historynode,right=of node1] {\nodepart{one} $\stkout{q_2}$ \nodepart{two} $1$};
\node (node3) [historynode,right=of node2] {\nodepart{one} $q_3$ \nodepart{two} $2$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $6$};

% Edges
\draw[->] (node0.two east) -- (node1.one west);
\draw[->] (node1.two east) -- (node2.one west);
\draw[->] (node2.two east) -- (node3.one west);
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);

% External references
\draw[->,dashed] (node0.one split south) ++(0,-1) node[below,draw=none] {C} -- ++(0,1);
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(-1.3,-1) node[below,draw=none] {A} -- ++(1.1,1);
\draw[->,dashed] (node5.one split south) ++(-0.7,-1) node[below,draw=none] {B} -- ++(0.6,1);
\draw[->,dashed] (node5.one split south) ++(-0.1,-1) node[below,draw=none] {D} -- ++(0.05,1);
\draw[->,dashed] (node5.one split south) ++(0.5,-1) node[below,draw=none] {E} -- ++(-0.4,1);
\draw[->,dashed] (node5.one split south) ++(1.5,-1) node[below,draw=none] {\texttt{Latest}} -- ++(-1.2,1);

\end{tikzpicture}
\caption{\texttt{varhistory} after deletion of column $q_2$ and deactivation of node B.}
\label{fig:gm_sync_history_deactivate_B}
\end{figure}

Finally, we activate node C. Upon node activation, we realize that the element that C points to in the \texttt{varhistory} has a next element. This means that there are new columns that have been generated since the last time C was active. We now forward the pointer of C one by one until there is no next element, i.e. until we reach the \texttt{Latest} pointer. Each time we forward the pointer, if the variable $q_i$ is not marked as deleted, we pass it to the branching rule, which can then set the coefficient of $q_i$ in the mastercut of C.

Whenever we forward a pointer, either step-by-step or by jumping to the \texttt{Latest} pointer, the internal reference count of the elements in the list are updated. As soon as this reference count reaches zero, the element can be safely freed. This way, we ensure that only variables that are actually needed, i.e. those that still need to be synchronized across the entire B\&B-tree are kept in memory. This is illustrated in Figure \ref{fig:gm_sync_history_activate_C}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node3) [historynode] {\nodepart{one} $q_3$ \nodepart{two} $1$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $7$};

% Edges
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);

% External references
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(-1.6,-1) node[below,draw=none] {A} -- ++(1.3,1);
\draw[->,dashed] (node5.one split south) ++(-1,-1) node[below,draw=none] {B} -- ++(0.8,1);
\draw[->,dashed] (node5.one split south) ++(-0.4,-1) node[below,draw=none] {C} -- ++(0.3,1);
\draw[->,dashed] (node5.one split south) ++(0.2,-1) node[below,draw=none] {D} -- ++(-0.1,1);
\draw[->,dashed] (node5.one split south) ++(0.8,-1) node[below,draw=none] {E} -- ++(-0.6,1);
\draw[->,dashed] (node5.one split south) ++(1.8,-1) node[below,draw=none] {\texttt{Latest}} -- ++(-1.5,1);

\end{tikzpicture}
\caption{\texttt{varhistory} after activation of node C.}
\label{fig:gm_sync_history_activate_C}
\end{figure}

Assume in node C we now generate a new column $q_6$. We add this column to the \texttt{varhistory} by allocating a new list element, setting its reference count to $1$, and setting the next pointer of the current \texttt{Latest} element to the new element, and finally forwarding the \texttt{Latest} pointer to the new element. This is illustrated in Figure \ref{fig:gm_sync_history_generate_q6}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=2,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node3) [historynode] {\nodepart{one} $q_3$ \nodepart{two} $1$};
\node (node4) [historynode,right=of node3] {\nodepart{one} $q_4$ \nodepart{two} $1$};
\node (node5) [historynode,right=of node4] {\nodepart{one} $q_5$ \nodepart{two} $6$};
\node (node6) [historynode,right=of node5] {\nodepart{one} $q_6$ \nodepart{two} $1$};

% Edges
\draw[->] (node3.two east) -- (node4.one west);
\draw[->] (node4.two east) -- (node5.one west);
\draw[->] (node5.two east) -- (node6.one west);

% External references
\draw[->,dashed] (node3.one split south) ++(0,-1) node[below,draw=none] {\textit{other}} -- ++(0,1);
\draw[->,dashed] (node5.one split south) ++(-1.6,-1) node[below,draw=none] {A} -- ++(1.3,1);
\draw[->,dashed] (node5.one split south) ++(-1,-1) node[below,draw=none] {B} -- ++(0.8,1);
\draw[->,dashed] (node5.one split south) ++(-0.4,-1) node[below,draw=none] {C} -- ++(0.3,1);
\draw[->,dashed] (node5.one split south) ++(0.2,-1) node[below,draw=none] {D} -- ++(-0.1,1);
\draw[->,dashed] (node5.one split south) ++(0.8,-1) node[below,draw=none] {E} -- ++(-0.6,1);
\draw[->,dashed] (node6.one split south) ++(0,-1) node[below,draw=none] {\texttt{Latest}} -- ++(0,1);

\end{tikzpicture}
\caption{\texttt{varhistory} after generating column $q_6$ in node C.}
\label{fig:gm_sync_history_generate_q6}
\end{figure}

This approach is highly efficient, as we only need to update the reference count of the elements in the list, and we only need to pass the variables to the branching rule that are actually new. The deletion of variables is also not of an issue here, as we simply do not pass them to the branching rules. As soon as all external references have seen some variable $q_i$, i.e. its reference count reaches zero, we can then automatically free the memory of the element in the list holding $q_i$. In this way, we can also minimize the memory footprint of the \texttt{varhistory} construct.

And as a final note, this approach is not limited for synchronization of master variables across the B\&B-tree, but can also be used for other purposes, which have symbolized by the \textit{other} reference in the above figures. Such other purposes, for example would be keeping master separators up-to-date (Section \ref{sec:cg_bp_bpc_separators_master}) . For more details on this, we refer to the thesis of Chantal Reinartz Groba \cite{TODO}.

\subsection{History Tracking using Unrolled Linked Lists Approach}\label{subsec:gm_sync_history_unrolled}
The approach described above has one optimization opportunity: as the elements of the \texttt{varhistory} might be allocated in completely different memory locations, the traversal of the list, i.e. during forwarding, would lead to poor cache utilization, resulting in many memory accesses. However, storing the entire list in a contiguous memory block, growing to the right, could lead to expensive reallocation and copying of the entire list, if no more space to the right is available.

We can combine these two ideas by unrolling our linked list into blocks storing a fixed amount of columns, where now each block has its own reference count. Once again, these blocks are linked together, forming a list of blocks. The references to the \texttt{varhistory} do not point to individual elements, but rather to the blocks, in addition to holding an offset within the block. This way, each reference still refers to some $q_i$, thus enabling us to forward a pointer one column at a time. Whenever a new variable is generated, we only allocate a new block if the current tail block is full. Otherwise, we simply add the new variable to the tail block. This concept is illustrated in Figure \ref{fig:gm_sync_history_unrolled}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[historynode/.style={
						draw,
						rectangle split,
						rectangle split horizontal,
						rectangle split parts=5,
					},
					every edge/.style={draw, -{Stealth[length=2mm, width=2mm]}},
					node distance=1cm and 1cm]

% Nodes
\node (node0) [historynode] at (0,0) {
	\nodepart{one} $q_0$
	\nodepart{two} $q_3$
	\nodepart{three} $q_2$
	\nodepart{four} $q_3$
	\nodepart{five} $3$
};
\node (node1) [historynode,right=of node0] {
	\nodepart{one} $q_4$
	\nodepart{two} $q_5$
	\nodepart{three}
	\nodepart{four}
	\nodepart{five} $3$
};

% Edges
\draw[->] (node0.two east) -- (node1.one west);

% External references
\draw[->,dashed] (node0.three south) ++(-1.8,-1) node[below,draw=none] {C,0} -- ++(1.6,1);
\draw[->,dashed] (node0.three south) ++(-0.9,-1) node[below,draw=none] {A,2} -- ++(0.8,1);
\draw[->,dashed] (node0.three south) ++(0,-1) node[below,draw=none] {B,2} -- ++(0,1);
\draw[->,dashed] (node0.three south) ++(1.2,-1) node[below,draw=none] {\textit{other},3} -- ++(-1.1,1);
\draw[->,dashed] (node1.three south) ++(0,-1) node[below,draw=none] {\texttt{Latest},1} -- ++(0,1);

\end{tikzpicture}
\caption{\texttt{varhistory} of Figure \ref{fig:gm_sync_history} unrolled into blocks of size 4.}
\label{fig:gm_sync_history_unrolled}
\end{figure}

This way, we can improve cache locality, and as a bonus also reduce the total number of memory allocation and deallocation operations, though from an outside perspective the fundamental operations of the \texttt{varhistory} construct remain the same.
